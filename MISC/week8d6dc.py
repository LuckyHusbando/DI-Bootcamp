# -*- coding: utf-8 -*-
"""Week8D6DC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CsZKVZm5CiSzTqQSriqzM1xQh9QOkri9
"""

!pip install Matplotlib
!pip install Seaborn

"""## Correlation Heatmap

### Subtask:
Create a heatmap using Seaborn to identify correlations between numerical columns like `IMDB_Rating`, `Meta_score`, `No_of_votes`, and `Gross`.

**Reasoning**:
Select the numerical columns relevant for the heatmap, calculate the correlation matrix, and then create a heatmap using seaborn to visualize the correlations with annotations for better readability.
"""

# Select the numerical columns for the heatmap
numerical_cols = ['IMDB_Rating', 'Meta_score', 'No_of_Votes', 'Gross']
correlation_matrix = df[numerical_cols].corr()

# Create a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap of Numerical Columns')
plt.show()

"""## Box Plot of Genres vs. Ratings

### Subtask:
Visualize the distribution of IMDB_Rating across different `Genre`s using a box plot.

**Reasoning**:
Select the relevant columns and create a box plot to visualize the distribution of IMDB ratings across different genres. Rotate x-axis labels for readability.
"""

# Create a box plot for IMDB_Rating by Genre
plt.figure(figsize=(20, 8)) # Adjusted figure size for better readability
sns.boxplot(x='Genre', y='IMDB_Rating', data=df)

# Label the axes and add a title
plt.xlabel('Genre')
plt.ylabel('IMDB Rating')
plt.title('Distribution of IMDB Rating by Genre')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Adjust layout to prevent labels overlapping
plt.tight_layout()

# Display the plot
plt.show()

"""# Task
Analyze the "imdb_top_1000.csv" dataset by performing data loading, inspection, preprocessing, and generating visualizations including line plots for rating trends over years, bar plots for genre popularity, scatter plots for director impact on ratings, pair plots for star power analysis, box plots for genre vs. ratings, and a correlation heatmap.

## Load and inspect data

### Subtask:
Load the `imdb_top_1000.csv` file into a pandas DataFrame and display the first few rows, the column names and their data types, and a summary of the DataFrame.

**Reasoning**:
Import pandas and load the dataset into a DataFrame, then display the head, info, and describe of the DataFrame as requested.
"""

import pandas as pd

df = pd.read_csv('imdb_top_1000.csv')

display(df.head())
display(df.info())
display(df.describe())

"""## Data preprocessing

### Subtask:
Handle missing values and convert data types as needed.

**Reasoning**:
Inspect columns with missing values, decide on an imputation strategy for 'Meta_score' and 'Gross' based on their distributions, convert 'Gross' and 'Released_Year' to numerical types, handle missing values in 'Certificate', and display the DataFrame information to confirm the changes.
"""

# Inspect missing values in relevant columns
print("Missing values before handling:")
display(df[['Certificate', 'Meta_score', 'Gross']].isnull().sum())

# Impute 'Meta_score' with the median
df['Meta_score'] = df['Meta_score'].fillna(df['Meta_score'].median())

# Convert 'Gross' to numeric, removing commas and filling NaNs with the median of the *converted* column
df['Gross'] = df['Gross'].str.replace(',', '', regex=False)
df['Gross'] = pd.to_numeric(df['Gross'])
df['Gross'] = df['Gross'].fillna(df['Gross'].median())

# Convert 'Released_Year' to numeric
df['Released_Year'] = pd.to_numeric(df['Released_Year'], errors='coerce')

# Handle missing values in 'Certificate' by filling with 'Unknown'
df['Certificate'] = df['Certificate'].fillna('Unknown')

# Display information after handling missing values and converting types
print("\nDataFrame Info after handling missing values and type conversion:")
display(df.info())

"""**Reasoning**:
The previous step handled the missing values in 'Certificate', 'Meta_score', and 'Gross' and converted 'Gross' to numeric. However, the `df.info()` output shows that 'Released_Year' still has one missing value and is of float64 type, although it should be an integer. The 'Runtime' column is still of object type and needs to be converted to a numerical format (e.g., minutes) for potential future analysis. I will address these remaining issues in the next step.


"""

# Fill the missing value in 'Released_Year' with the mode (most frequent year)
df['Released_Year'] = df['Released_Year'].fillna(df['Released_Year'].mode()[0])

# Convert 'Released_Year' to integer type
df['Released_Year'] = df['Released_Year'].astype(int)

# Convert 'Runtime' to numerical (minutes)
df['Runtime'] = df['Runtime'].str.replace(' min', '', regex=False)
df['Runtime'] = pd.to_numeric(df['Runtime'])

# Display information again to confirm changes
print("\nDataFrame Info after final type conversions and handling remaining missing values:")
display(df.info())

"""## Rating trends over years

### Subtask:
Create a line plot showing trends in `IMDB_Rating` over the years.

**Reasoning**:
Group the data by year and calculate the average IMDB rating, then create a line plot to visualize the trend.
"""

import matplotlib.pyplot as plt

# Group by 'Released_Year' and calculate the mean 'IMDB_Rating'
rating_trend = df.groupby('Released_Year')['IMDB_Rating'].mean()

# Create the line plot
plt.figure(figsize=(12, 6))
plt.plot(rating_trend.index, rating_trend.values)
plt.xlabel('Release Year')
plt.ylabel('Average IMDB Rating')
plt.title('Average IMDB Rating Over the Years')
plt.grid(True)
plt.show()

"""## Genre popularity analysis

### Subtask:
Generate a bar plot to compare the number of movies across different `Genre`s.

**Reasoning**:
Count the occurrences of each genre and create a bar plot to visualize the distribution.
"""

# Count the number of movies per genre
genre_counts = df['Genre'].value_counts()

# Create a bar plot
plt.figure(figsize=(15, 7)) # Adjusted figure size for better readability
genre_counts.plot(kind='bar')
plt.xlabel('Genre')
plt.ylabel('Number of Movies')
plt.title('Number of Movies per Genre')
plt.xticks(rotation=90) # Rotate x-axis labels for better visibility
plt.tight_layout() # Adjust layout to prevent labels overlapping
plt.show()

"""## Directorâ€™s impact on ratings

### Subtask:
Create a scatter plot to examine the relationship between `Director`s and movie ratings.

**Reasoning**:
Calculate the average IMDB rating for each director and then create a scatter plot to visualize the relationship between directors and their average ratings. Rotate x-axis labels for readability.
"""

# Calculate the average IMDB_Rating for each Director
director_avg_rating = df.groupby('Director')['IMDB_Rating'].mean().sort_values(ascending=False)

# Create a scatter plot
plt.figure(figsize=(15, 7))
plt.scatter(director_avg_rating.index, director_avg_rating.values)

# Label the axes and add a title
plt.xlabel('Director')
plt.ylabel('Average IMDB Rating')
plt.title('Average IMDB Rating by Director')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Adjust layout to prevent labels overlapping
plt.tight_layout()

# Display the plot
plt.show()

"""## Star power analysis

### Subtask:
Generate a pairplot to explore relationships involving `Star1`, `Star2`, `Star3`, and `Star4` and their impact on `IMDB_Rating` and `Gross`.

**Reasoning**:
Import the seaborn library and select the relevant columns for the pairplot.
"""

import seaborn as sns

# Select the relevant columns for the pairplot
pairplot_cols = ['IMDB_Rating', 'Gross', 'Star1', 'Star2', 'Star3', 'Star4']

"""**Reasoning**:
Generate and display the pairplot using the selected columns.


"""

# Create a pairplot using sns.pairplot() with the selected columns
sns.pairplot(df[pairplot_cols])

# Display the generated pairplot
plt.show()

"""**Reasoning**:
The pairplot with the star columns is not included in the output, so regenerate the pairplot including the star columns.


"""

# Create a pairplot including Star1, Star2, Star3, and Star4
sns.pairplot(df, vars=['IMDB_Rating', 'Gross'], hue='Star1')
plt.show()

sns.pairplot(df, vars=['IMDB_Rating', 'Gross'], hue='Star2')
plt.show()

sns.pairplot(df, vars=['IMDB_Rating', 'Gross'], hue='Star3')
plt.show()

sns.pairplot(df, vars=['IMDB_Rating', 'Gross'], hue='Star4')
plt.show()

"""# Task
Analyze the "imdb_top_1000.csv" dataset by performing the following steps in Python: Load and inspect the data, preprocess it by handling missing values and converting data types, create a line plot showing IMDB_Rating trends over the years, generate a bar plot for genre popularity, create a scatter plot to examine the relationship between directors and ratings, employ a pairplot to explore relationships involving stars and their impact on IMDB_Rating and Gross, visualize the distribution of IMDB_Rating across genres using a box plot, and create a correlation heatmap for numerical columns. Use the file "imdb_top_1000.csv".

## Summary:

### Data Analysis Key Findings

*   The line plot shows a general increasing trend in the average IMDB Rating over the years, particularly after 1940, suggesting a rise in the perceived quality of top-rated films in recent decades.
*   The bar plot indicates that 'Drama' is by far the most popular genre, appearing in the highest number of top-rated films, followed by 'Comedy' and 'Action'.
*   The scatter plot exploring the relationship between directors and ratings does not show a clear linear trend, suggesting that director influence on IMDB rating might be more nuanced than a simple linear relationship.
*   The box plot reveals that 'Drama' and 'Animation' genres have the highest median IMDB ratings among the top 1000 films.
*   The correlation heatmap highlights strong positive correlations between 'Gross' earnings and both 'Meta\_score' and 'No\_of\_Votes'. It also shows a moderate positive correlation between 'IMDB\_Rating' and 'Meta\_score'.

### Insights or Next Steps

*   Investigate the factors contributing to the upward trend in average IMDB ratings over the years.
*   Further explore the impact of specific directors on film ratings by analyzing their filmographies and average ratings in more detail.
"""